* Syntaxes
** function
def <function_name>(<parameters>):
    ....
    return
** if-else
if <condition>:
    ....
else:
    ....

It is helpful to note that Python does not support in line
assigment in the if statement, so you cannot end up accidentally
assigning values when you want to compare!


* Functions
** Begin with a keyword : def
*** The def line is terminated with a colon (:)
** Triple quotes right after the def line indicates a doc string
*** doc strings help provide context sensitive information
** Python functions have attributes that are available at runtime
** A function is an object!
*** It has a built in attribute, __doc__, the doc string


** Indentation is very important!
*** A function does not have an explicit beginning and an end
*** Defined merely by indentation
**** Applies to all code blocks, such as if, while, etc.


* Modules
** Import modules using the import command (can be .py files)
*** Once imported, you can reference any of its public classes, functions, etc
** When you import new modules, python looks in all places in sys.path
*** To view existing paths: sys.path
*** To add a new path: sys.path.append('mynew/path')
**** This effect is not permanent, and lasts only as long as the session
** If you want to use functions in imported module, reference it with a dot
*** eg. module.functionname
** Some built-in attributes
*** __name__ 
If you import the module, then the __name__ is the filename, otherwise
if you run it as a program, it has a special value __main__
*** __doc__
Reads the doc string in the function


* Dictionaries
** Define one-to-one relationships between keys and values
** You can get values by key, but not keys by values
** Dictionaries, by definition, are unordered.
** Dictionary Keys are case sensitive.
** Dictionary values can be of any data type. while keys are of a particular type
*** For keys: strings, integers are allowed
** Commands
*** Defining keys
    d = {"a":"b","c':"d"}
*** Accessing values
    d["a"] ------> b
*** Modifying values
    d["a"]="new"
*** Adding new values
    d["e"]="f"
*** Deleting dictionaries
**** del d["a"] -> Lets you delete individual keys
**** d.clear()  -> Clears an entire dictionary

* Lists
** Very similar to arrays in C++, but have the advantage of handling multiple data types
** List indices start from zero
** Negative indices will start accessing the list from backwards
*** One way to see negative indices is actual_index = length(list)-index
** List manipulation is very similar to MATLAB's syntax
** Commands
*** Initializing a list
**** l = ["a","b","x","y"];
*** Accessing an element
**** li[1], li[-1]
*** Splicing a list
**** li[1:4]. It should be noted that the 1st element will be included, while the 4th element will not.
**** From beginning to index (but not including the index)  : li[:index]
**** From index to end : li[index:]
**** All the elements : li[:]
*** 
